# -*- coding: utf-8 -*-
"""River_Width_batch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tum8E-eT9q1TpvBGClrtyvb7j1Ow6lcs
"""

import ee
import numpy as np
import math

# Trigger the authentication flow.
ee.Authenticate()

# Initialize the library.
ee.Initialize()

def GetWidth(clAngleNorm, segmentInfo, endInfo, DM, crs, bound, scale, sceneID, note):
    """calculate the width of the river at each centerline pixel, measured according to the orthgonal direction of the river
    """
    def GetXsectionEnds(f):
        xc = ee.Number(f.get('x'))
        yc = ee.Number(f.get('y'))
        orthRad = ee.Number(f.get('angle')).divide(180).multiply(math.pi)

        width = ee.Number(f.get('toBankDistance')).multiply(1.5)
        cosRad = width.multiply(orthRad.cos())
        sinRad = width.multiply(orthRad.sin())
        p1 = ee.Geometry.Point([xc.add(cosRad), yc.add(sinRad)], crs)
        p2 = ee.Geometry.Point([xc.subtract(cosRad), yc.subtract(sinRad)], crs)

        xlEnds = (ee.Feature(ee.Geometry.MultiPoint([p1, p2]).buffer(30), {
            'xc': xc,
            'yc': yc,
            'longitude': f.get('lon'),
            'latitude': f.get('lat'),
            'orthogonalDirection': orthRad,
            'MLength': width.multiply(2),
            'p1': p1,
            'p2': p2,
            'crs': crs,
            'image_id': sceneID,
            'note': note
            }))

        return xlEnds

def prepExport(f):
    f = (f.set({
        'width': ee.Number(f.get('MLength')).multiply(f.get('channelMask')),
        'endsInWater': ee.Number(f.get('any')).eq(1),
        'endsOverEdge': ee.Number(f.get('count')).lt(2)}))

    fOut = (ee.Feature(ee.Geometry.Point([f.get('longitude'), f.get('latitude')]), {})
    .copyProperties(f, None, ['any', 'count', 'MLength', 'xc', 'yc', 'channelMask']))
    return(fOut)

def hitOrMiss(image, se1, se2):
    """perform hitOrMiss transform (adapted from [citation])
    """
    e1 = image.reduceNeighborhood(ee.Reducer.min(), se1)
    e2 = image.Not().reduceNeighborhood(ee.Reducer.min(), se2)
    return e1.And(e2)

def splitKernel(kernel, value):
    """recalculate the kernel according to the given foreground value
    """
    kernel = np.array(kernel)
    result = kernel
    r = 0
    while (r < kernel.shape[0]):
        c = 0
        while (c < kernel.shape[1]):
            if kernel[r][c] == value:
                result[r][c] = 1
            else:
                result[r][c] = 0
            c = c + 1
        r = r + 1
    return result.tolist()

def Skeletonize(image, iterations, method):
    """perform skeletonization
    """

    se1w = [[2, 2, 2], [0, 1, 0], [1, 1, 1]]

    if (method == 2):
        se1w = [[2, 2, 2], [0, 1, 0], [0, 1, 0]]

    se11 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 1))
    se12 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 2))

    se2w = [[2, 2, 0], [2, 1, 1], [0, 1, 0]]

    if (method == 2):
        se2w = [[2, 2, 0], [2, 1, 1], [0, 1, 1]]

    se21 = ee.Kernel.fixed(3, 3, splitKernel(se2w, 1))
    se22 = ee.Kernel.fixed(3, 3, splitKernel(se2w, 2))

    result = image

    i = 0
    while (i < iterations):
        j = 0
        while (j < 4):
              result = result.subtract(hitOrMiss(result, se11, se12))
              se11 = se11.rotate(1)
              se12 = se12.rotate(1)
              result = result.subtract(hitOrMiss(result, se21, se22))
              se21 = se21.rotate(1)
              se22 = se22.rotate(1)
              j = j + 1
        i = i + 1

    return result.rename(['clRaw'])

def CalcDistanceMap(img, neighborhoodSize, scale):
    # // assign each river pixel with the distance (in meter) between itself and the closest non-river pixel
    imgD2 = img.focal_max(1.5, 'circle', 'pixels', 2)
    imgD1 = img.focal_max(1.5, 'circle', 'pixels', 1)
    outline = imgD2.subtract(imgD1)

    dpixel = outline.fastDistanceTransform(neighborhoodSize).sqrt()
    dmeters = dpixel.multiply(scale) #// for a given scale
    DM = dmeters.mask(dpixel.lte(neighborhoodSize).And(imgD2))

    return(DM)

def CalcGradientMap(image, gradMethod, scale):
    ## Calculate the gradient
    if (gradMethod == 1): # GEE .gradient() method
        grad = image.gradient()
        dx = grad.select(['x'])
        dy = grad.select(['y'])
        g = dx.multiply(dx).add(dy.multiply(dy)).sqrt()

    if (gradMethod == 2): # Gena's method
        k_dx = ee.Kernel.fixed(3, 3, [[ 1.0/8, 0.0, -1.0/8], [ 2.0/8, 0.0, -2.0/8], [ 1.0/8,  0.0, -1.0/8]])
        k_dy = ee.Kernel.fixed(3, 3, [[ -1.0/8, -2.0/8, -1.0/8], [ 0.0, 0.0, 0.0], [ 1.0/8, 2.0/8, 1.0/8]])
        dx = image.convolve(k_dx)
        dy = image.convolve(k_dy)
        g = dx.multiply(dx).add(dy.multiply(dy)).divide(scale.multiply(scale)).sqrt()

    if (gradMethod == 3): # RivWidth method
        k_dx = ee.Kernel.fixed(3, 1, [[-0.5, 0.0, 0.5]])
        k_dy = ee.Kernel.fixed(1, 3, [[0.5], [0.0], [-0.5]])
        dx = image.convolve(k_dx)
        dy = image.convolve(k_dy)
        g = dx.multiply(dx).add(dy.multiply(dy)).divide(scale.multiply(scale))

    return(g)

def CalcOnePixelWidthCenterline(img, GM, hGrad):
    # /***
    # calculate the 1px centerline from:
    # 1. fast distance transform of the river banks
    # 2. gradient of the distance transform, mask areas where gradient greater than a threshold hGrad
    # 3. apply skeletonization twice to get a 1px centerline
    # thresholding gradient map inspired by Pavelsky and Smith., 2008
    # ***/

    imgD2 = img.focal_max(1.5, 'circle', 'pixels', 2)
    cl = ee.Image(GM).mask(imgD2).lte(hGrad).And(img)
    # // apply skeletonization twice
    cl1px = Skeletonize(cl, 2, 1)
    return(cl1px)

def ExtractEndpoints(CL1px):
    """calculate end points in the one pixel centerline
    """

    se1w = [[0, 0, 0], [2, 1, 2], [2, 2, 2]]

    se11 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 1))
    se12 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 2))

    result = CL1px

    # // the for loop removes the identified endpoints from the imput image
    i = 0
    while (i<4): # rotate kernels
        result = result.subtract(hitOrMiss(CL1px, se11, se12))
        se11 = se11.rotate(1)
        se12 = se12.rotate(1)
        i = i + 1
    endpoints = CL1px.subtract(result)
    return endpoints

def ExtractCorners(CL1px):
    """calculate corners in the one pixel centerline
    """

    se1w = [[2, 2, 0], [2, 1, 1], [0, 1, 0]]

    se11 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 1))
    se12 = ee.Kernel.fixed(3, 3, splitKernel(se1w, 2))

    result = CL1px
    # // the for loop removes the identified corners from the imput image

    i = 0
    while(i < 4): # rotate kernels

        result = result.subtract(hitOrMiss(result, se11, se12))

        se11 = se11.rotate(1)
        se12 = se12.rotate(1)

        i = i + 1

    cornerPoints = CL1px.subtract(result)
    return cornerPoints

def CleanCenterline(cl1px, maxBranchLengthToRemove, rmCorners):
    """clean the 1px centerline:
	1. remove branches
	2. remove corners to insure 1px width (optional)
    """

    ## find the number of connecting pixels (8-connectivity)
    nearbyPoints = (cl1px.mask(cl1px).reduceNeighborhood(
        reducer = ee.Reducer.count(),
        kernel = ee.Kernel.circle(1.5),
        skipMasked = True))

	## define ends
    endsByNeighbors = nearbyPoints.lte(2)

	## define joint points
    joints = nearbyPoints.gte(4)

    costMap = (cl1px.mask(cl1px).updateMask(joints.Not()).cumulativeCost(
        source = endsByNeighbors.mask(endsByNeighbors),
        maxDistance = maxBranchLengthToRemove,
        geodeticDistance = True))

    branchMask = costMap.gte(0).unmask(0)
    cl1Cleaned = cl1px.updateMask(branchMask.Not()) # mask short branches;
    ends = ExtractEndpoints(cl1Cleaned)
    cl1Cleaned = cl1Cleaned.updateMask(ends.Not())

    if (rmCorners):
        corners = ExtractCorners(cl1Cleaned)
        cl1Cleaned = cl1Cleaned.updateMask(corners.Not())

    return cl1Cleaned


def CalculateAngle(clCleaned):
    """calculate the orthogonal direction of each pixel of the centerline
    """

    w3 = (ee.Kernel.fixed(9, 9, [
    [135.0, 126.9, 116.6, 104.0, 90.0, 76.0, 63.4, 53.1, 45.0],
    [143.1, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 36.9],
    [153.4, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 26.6],
    [166.0, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 14.0],
    [180.0, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 1e-5],
    [194.0, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 346.0],
    [206.6, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 333.4],
    [216.9, 0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0, 323.1],
    [225.0, 233.1,  243.4,  256.0,  270.0,  284.0,  296.6,  306.9, 315.0]]))

    combinedReducer = ee.Reducer.sum().combine(ee.Reducer.count(), None, True)

    clAngle = (clCleaned.mask(clCleaned)
        .rename(['clCleaned'])
        .reduceNeighborhood(
        reducer = combinedReducer,
        kernel = w3,
        inputWeight = 'kernel',
        skipMasked = True))

	## mask calculating when there are more than two inputs into the angle calculation
    clAngleNorm = (clAngle
        .select('clCleaned_sum')
        .divide(clAngle.select('clCleaned_count'))
        .mask(clAngle.select('clCleaned_count').gt(2).Not()))

	## if only one input into the angle calculation, rotate it by 90 degrees to get the orthogonal
    clAngleNorm = (clAngleNorm
        .where(clAngle.select('clCleaned_count').eq(1), clAngleNorm.add(ee.Image(90))))

    return clAngleNorm.rename(['orthDegree'])

def GetWidth(clAngleNorm, segmentInfo, endInfo, DM, crs, bound, scale, sceneID, note):
    """calculate the width of the river at each centerline pixel, measured according to the orthgonal direction of the river
    """
    def GetXsectionEnds(f):
        xc = ee.Number(f.get('x'))
        yc = ee.Number(f.get('y'))
        orthRad = ee.Number(f.get('angle')).divide(180).multiply(math.pi)

        width = ee.Number(f.get('toBankDistance')).multiply(1.5)
        cosRad = width.multiply(orthRad.cos())
        sinRad = width.multiply(orthRad.sin())
        p1 = ee.Geometry.Point([xc.add(cosRad), yc.add(sinRad)], crs)
        p2 = ee.Geometry.Point([xc.subtract(cosRad), yc.subtract(sinRad)], crs)

        xlEnds = (ee.Feature(ee.Geometry.MultiPoint([p1, p2]).buffer(30), {
            'xc': xc,
            'yc': yc,
            'longitude': f.get('lon'),
            'latitude': f.get('lat'),
            'orthogonalDirection': orthRad,
            'MLength': width.multiply(2),
            'p1': p1,
            'p2': p2,
            'crs': crs,
            'image_id': sceneID,
            'note': note
            }))

        return xlEnds

    def SwitchGeometry(f):
        return (f
        .setGeometry(ee.Geometry.LineString(coords = [f.get('p1'), f.get('p2')], proj = crs, geodesic = False))
        .set('p1', None).set('p2', None)) # remove p1 and p2

    ## convert centerline image to a list. prepare for map function
    clPoints = (clAngleNorm.rename(['angle'])
    	.addBands(ee.Image.pixelCoordinates(crs))
        .addBands(ee.Image.pixelLonLat().rename(['lon', 'lat']))
        .addBands(DM.rename(['toBankDistance']))
        .sample(
            region = bound,
            scale = scale,
            projection = None,
            factor = 1,
            dropNulls = True
        ))

	## calculate the cross-section lines, returning a featureCollection
    xsectionsEnds = clPoints.map(GetXsectionEnds)

	## calculate the flags at the xsection line end points
    endStat = (endInfo.reduceRegions(
        collection = xsectionsEnds,
        reducer = ee.Reducer.anyNonZero().combine(ee.Reducer.count(), None, True), # test endpoints type
        scale = scale,
        crs = crs))

	## calculate the width of the river and other flags along the xsection lines
    xsections1 = endStat.map(SwitchGeometry)
    combinedReducer = ee.Reducer.mean()
    xsections = (segmentInfo.reduceRegions(
        collection = xsections1,
        reducer = combinedReducer,
        scale = scale,
        crs = crs))

    return xsections

def CalculateCenterline(imgIn):

    crs = imgIn.get('crs')
    scale = ee.Number(imgIn.get('scale'))
    riverMask = imgIn.select(['riverMask'])

    distM = CalcDistanceMap(riverMask, 256, scale)
    gradM = CalcGradientMap(distM, 2, scale)
    cl1 = CalcOnePixelWidthCenterline(riverMask, gradM, 0.9)
    cl1Cleaned1 = CleanCenterline(cl1, 300, True)
    cl1px = CleanCenterline(cl1Cleaned1, 300, False)

    imgOut = (imgIn
    .addBands(cl1px.rename(['cleanedCL']))
    .addBands(cl1.rename(['rawCL']))
    .addBands(gradM.rename(['gradientMap']))
    .addBands(distM.rename(['distanceMap'])))

    return(imgOut)

def CalculateOrthAngle(imgIn):
    cl1px = imgIn.select(['cleanedCL'])
    angle = CalculateAngle(cl1px)
    imgOut = imgIn.addBands(angle)
    return(imgOut)

def prepExport(f):
    f = (f.set({
        'width': ee.Number(f.get('MLength')).multiply(f.get('channelMask')),
        'endsInWater': ee.Number(f.get('any')).eq(1),
        'endsOverEdge': ee.Number(f.get('count')).lt(2)}))

    fOut = (ee.Feature(ee.Geometry.Point([f.get('longitude'), f.get('latitude')]), {})
    .copyProperties(f, None, ['any', 'count', 'MLength', 'xc', 'yc', 'channelMask']))
    return(fOut)

def CalculateWidth(imgIn):
    crs = imgIn.get('crs')
    scale = imgIn.get('scale')
    imgId = imgIn.get('image_id')
    bound = imgIn.select(['riverMask']).geometry()
    angle = imgIn.select(['orthDegree'])
    dem = ee.Image("MERIT/DEM/v1_0_3") #change
    infoEnds = imgIn.select(['riverMask'])
    infoExport = (imgIn.select('channelMask')
    .addBands(imgIn.select('^flag.*'))
    .addBands(dem.rename(['flag_elevation'])))
    dm = imgIn.select(['distanceMap'])

    widths = GetWidth(angle, infoExport, infoEnds, dm, crs, bound, scale, imgId, '').map(prepExport)

    return(widths)

def merge_collections_std_bandnames_collection2tier1_sr():
    """merge landsat 5, 7, 8, 9 level 2 collection 2 tier 1 imageCollections and standardize band names
    """
    ## standardize band names
    bn9 = ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B6', 'QA_PIXEL', 'SR_B5', 'SR_B7'];
    bn8 = ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B6', 'QA_PIXEL', 'SR_B5', 'SR_B7'];
    bn7 = ['SR_B1', 'SR_B1', 'SR_B2', 'SR_B3', 'SR_B5', 'QA_PIXEL', 'SR_B4', 'SR_B7'];
    bn5 = ['SR_B1', 'SR_B1', 'SR_B2', 'SR_B3', 'SR_B5', 'QA_PIXEL', 'SR_B4', 'SR_B7'];
    bns = ['uBlue', 'Blue', 'Green', 'Red', 'Swir1', 'BQA', 'Nir', 'Swir2'];

    # create a merged collection from landsat 5, 7, 8 and 9
    ls5 = ee.ImageCollection("LANDSAT/LT05/C02/T1_L2").select(bn5, bns)

    ls7 = (ee.ImageCollection("LANDSAT/LE07/C02/T1_L2")
           .filterDate('2016-04-15', '2023-01-28')
           .select(bn7, bns))

    ls8 = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2").select(bn8, bns)

    ls9 = ee.ImageCollection("LANDSAT/LC09/C02/T1_L2").select(bn9, bns)

    merged = ls5.merge(ls7).merge(ls8).merge(ls9)

    return(merged)

def id2Img(id):
    return(ee.Image(merge_collections_std_bandnames_collection2tier1_sr()
    .filterMetadata('LANDSAT_PRODUCT_ID', 'equals', id)
    .first()))

def Unpack(bitBand, startingBit, bitWidth):
    # unpacking bit bands
    # see: https://groups.google.com/forum/#!starred/google-earth-engine-developers/iSV4LwzIW7A
    return (ee.Image(bitBand)
            .rightShift(startingBit)
            .bitwiseAnd(ee.Number(2).pow(ee.Number(bitWidth)).subtract(ee.Number(1)).int()))
def UnpackAllSR(bitBand):
    # apply Unpack function for multiple pixel qualities
    bitInfoSR = {
    'Cloud': [3, 1],
    'CloudShadow': [4, 1],
    'SnowIce': [5, 1],
    'Water': [7, 1]
    }
    unpackedImage = ee.Image.cat([Unpack(bitBand, bitInfoSR[key][0], bitInfoSR[key][1]).rename([key]) for key in bitInfoSR])
    return unpackedImage
def AddFmaskSR(image):
    # // add fmask as a separate band to the input image
    temp = UnpackAllSR(image.select(['BQA']))

    fmask = (temp.select(['Water']).rename(['fmask'])
    .where(temp.select(['SnowIce']), ee.Image(3))
    .where(temp.select(['CloudShadow']), ee.Image(2))
    .where(temp.select(['Cloud']), ee.Image(4))
    .mask(temp.select(['Cloud']).gte(0)))

    return image.addBands(fmask)

def CalcHillShadowSR(image):
    dem = ee.Image("MERIT/DEM/v1_0_3").clip(image.geometry().buffer(9000).bounds())
    SOLAR_AZIMUTH_ANGLE = ee.Number(image.get('SUN_AZIMUTH'))
    SOLAR_ZENITH_ANGLE = ee.Number(90).subtract(image.getNumber('SUN_ELEVATION'))

    return(ee.Terrain.hillShadow(dem, SOLAR_AZIMUTH_ANGLE, SOLAR_ZENITH_ANGLE, 100, True)
    .reproject("EPSG:4326", None, 90).rename(['hillshadow']))

# /* functions to classify water (default) */
def ClassifyWater(imgIn, method = 'Jones2019'):

    if method == 'Jones2019':
        return(ClassifyWaterJones2019(imgIn))

# /* water function */
def CalculateWaterAddFlagsSR(imgIn, waterMethod = 'Fmask'):
    # waterMethod = typeof waterMethod !== 'undefined' ? waterMethod : 'Fmask';

    fmask = AddFmaskSR(imgIn).select(['fmask'])

    fmaskUnpacked = (fmask.eq(4).rename('flag_cloud')
    .addBands(fmask.eq(2).rename('flag_cldShadow'))
    .addBands(fmask.eq(3).rename('flag_snowIce'))
    .addBands(fmask.eq(1).rename('flag_water')))

    water = fmask.eq(1).rename(['waterMask']).where(fmask.gte(2), ee.Image.constant(0))
    hillshadow = CalcHillShadowSR(imgIn).Not().rename(['flag_hillshadow'])

    imgOut = (ee.Image(water.addBands(fmask).addBands(hillshadow).addBands(fmaskUnpacked)
    .setMulti({
        'image_id': imgIn.get('LANDSAT_PRODUCT_ID'),
        'timestamp': imgIn.get('system:time_start'),
        'scale': imgIn.projection().nominalScale(),
        'crs': imgIn.projection().crs()
    })))

    return(imgOut)

def GetCenterline(clDataset, bound):
    # // filter the GRWL centerline based on area of interest
    cl = clDataset.filterBounds(bound)
    return(cl)

def ExtractChannel(image, centerline, maxDistance):
    # // extract the channel water bodies from the water mask, based on connectivity to the reference centerline.
    connectedToCl = (image.Not().cumulativeCost(
        source = ee.Image().toByte().paint(centerline, 1).And(image), #// only use the centerline that overlaps with the water mask
        maxDistance = maxDistance,
        geodeticDistance = False).eq(0))

    channel = image.updateMask(connectedToCl).unmask(0).updateMask(image.gte(0)).rename(['channelMask'])
    return(channel)

def RemoveIsland(channel, FILL_SIZE):
    # /* fill in island as water if the size (number of pixels) of the island is smaller than FILL_SIZE */
    fill = channel.Not().selfMask().connectedPixelCount(FILL_SIZE).lt(FILL_SIZE)
    river = channel.where(fill, ee.Image(1)).rename(['riverMask'])
    return(river)

def ExtractRiver(imgIn, clData, maxDist, minIslandRemoval):
    waterMask = imgIn.select(['waterMask'])
    bound = waterMask.geometry()
    cl = GetCenterline(clData, bound)
    channelMask = ExtractChannel(waterMask, cl, maxDist)
    riverMask = RemoveIsland(channelMask, minIslandRemoval)
    return(imgIn.addBands(channelMask).addBands(riverMask))

def rwGenSR(aoi = None, WATER_METHOD = 'Jones2019', MAXDISTANCE = 4000, FILL_SIZE = 333, MAXDISTANCE_BRANCH_REMOVAL = 500):

    grwl = ee.FeatureCollection("users/eeProject/grwl")

    # // generate function based on user choice
    def tempFUN(image, aoi = aoi):
        aoi = ee.Algorithms.If(aoi, aoi, image.geometry())
        image = image.clip(aoi)

        # // derive water mask and masks for flags
        imgOut = CalculateWaterAddFlagsSR(image, WATER_METHOD)
        # // calculate river mask
        imgOut = ExtractRiver(imgOut, grwl, MAXDISTANCE, FILL_SIZE)
        # // calculate centerline
        imgOut = CalculateCenterline(imgOut)
        # // calculate orthogonal direction of the centerline
        imgOut = CalculateOrthAngle(imgOut)
        # // export widths
        widthOut = CalculateWidth(imgOut)

        return(widthOut)

    return(tempFUN)

def maximum_no_of_tasks(MaxNActive, waitingPeriod):
	"""maintain a maximum number of active tasks
	"""
	import time
	import ee
	ee.Initialize()

	time.sleep(10)
	## initialize submitting jobs
	ts = list(ee.batch.Task.list())

	NActive = 0
	for task in ts:
		if ('RUNNING' in str(task) or 'READY' in str(task)):
			NActive += 1
	## wait if the number of current active tasks reach the maximum number
	## defined in MaxNActive
	while (NActive >= MaxNActive):
		time.sleep(waitingPeriod) # if reach or over maximum no. of active tasks, wait for 2min and check again
		ts = list(ee.batch.Task.list())
		NActive = 0
		for task in ts:
			if ('RUNNING' in str(task) or 'READY' in str(task)):
				NActive += 1
	return()

import numpy as np
import pandas as pd
import os
from os import listdir

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/gdrive')
# %cd /gdrive/MyDrive

!ls

MAXIMUM_NO_OF_TASKS=6
START_NO = 0
FORMAT = 'csv'
OUTPUT_FOLDER = 'Water Width'

imageInfo = pd.read_csv('landsatID.csv', dtype = {'LANDSAT_ID': np.unicode_})
sceneIDList = imageInfo['LANDSAT_ID'].values.tolist()

N = len(sceneIDList)

for n in range(START_NO, N):

        ee.Initialize()

        # start of program
        img = id2Img(sceneIDList[n])
        rwc = rwGenSR()
        exportPrefix = sceneIDList[n] 

        widthOut = rwc(img)

        taskWidth = (ee.batch.Export.table.toDrive(
            collection = widthOut,
            description = exportPrefix,
            folder = OUTPUT_FOLDER,
            fileNamePrefix = exportPrefix,
            fileFormat = FORMAT))
        taskWidth.start()

        print('')
        print(exportPrefix, 'will be exported to', OUTPUT_FOLDER, 'as', FORMAT, 'file')

        maximum_no_of_tasks(MAXIMUM_NO_OF_TASKS, 30)

        print('submitted task ', n + 1, ' of ', N)

